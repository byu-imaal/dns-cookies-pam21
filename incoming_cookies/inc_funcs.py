"""
Collection of functions for analyzing data generated by `inc_cookie_parser.py`
Designed to run a single function via CLI
"""

import argparse
import inspect
import sys
from collections import defaultdict

from shared.asutils import ip_to_as_info
from shared.fileutils import jl_iter


def qip_freq(it):
    TOP = 1000
    res = defaultdict(set)
    og_set = set()

    for j in it:
        res[j['query_ip']].add(j['og_ip'])
        og_set.add(j['og_ip'])

    res_count = defaultdict(int)
    for qip, ogs in res.items():
        res_count[qip] = len(ogs)

    total_ogs = len(og_set)
    top_og_set = set()
    top_qips = []

    i = 0
    for qip, count in sorted(res_count.items(), key=lambda k: k[1], reverse=True):
        for og in res[qip]:
            top_og_set.add(og)
        top_qips.append(qip)

        print(f'{qip}: {count} ({count / total_ogs * 100}%)')
        i += 1
        if i > TOP:
            break
    print(f'For top {i} IPs: {len(top_og_set)} ({len(top_og_set) / total_ogs * 100}%)')

    asn_info = ip_to_as_info(top_qips, True)
    qip2asn = {line.split("|")[1].strip(): line.split("|")[0].strip()
               for line in asn_info.split('\n') if len(line.split("|")) > 2}
    asn2og = defaultdict(set)
    for ip, asn in qip2asn.items():
        for og in res[ip]:
            asn2og[asn].add(og)

    print('*' * 100)
    for asn, ogs in sorted(asn2og.items(), key=lambda k: len(k[1]), reverse=True):
        print(f'{asn}: {len(ogs)} ({len(ogs) / total_ogs * 100}%)')


def support_by_qip(it):
    res = defaultdict(list)

    for j in it:
        res[j['query_ip']].append(j['cookie'] is not None)

    no_support = 0
    some_support = 0
    support = 0
    for q_ip, cookies in res.items():
        if all(cookies):
            support += 1
        elif any(cookies):
            some_support += 1
        else:
            no_support += 1

    print(f"Total: {len(res)}")
    print(f"No Support: {no_support} ({no_support / len(res)}")
    print(f"Some Support: {some_support} ({some_support / len(res)}")
    print(f"Support: {support} ({support / len(res)}")


if __name__ == "__main__":
    possible_funcs = []
    for name, obj in inspect.getmembers(sys.modules[__name__]):
        if inspect.isfunction(obj) and not name.startswith('_'):
            possible_funcs.append(obj)

    parser = argparse.ArgumentParser(description="")
    parser.add_argument('input', help="Input file")
    parser.add_argument('func', help="Function to run", choices=[f.__name__ for f in possible_funcs])

    args = parser.parse_args()

    for f in possible_funcs:
        if f.__name__ == args.func:
            with open(args.input, 'r') as in_file:
                f(jl_iter(in_file))
